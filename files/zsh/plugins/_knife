#compdef knife

# These flags should be available everywhere according to man knife
knife_general_flags=( --help --server-url --key --config --editor --format --log_level --logfile --no-editor --user --print-after --version --yes )

# knife has a very special syntax, some example calls are:
# knife status
# knife cookbook list
# knife role show ROLENAME
# knife data bag show DATABAGNAME
# knife role show ROLENAME --attribute ATTRIBUTENAME
# knife cookbook show COOKBOOKNAME COOKBOOKVERSION recipes

# The -Q switch in compadd allow for completions of things like "data bag" without having to go through two rounds of completion and avoids zsh inserting a \ for escaping spaces
_knife() {
  local curcontext="$curcontext" state line
  typeset -A opt_args
  _arguments \
    '1: :->knifecmd'\
    '2: :->knifesubcmd'\
    '3: :->knifesubcmd2' \
    '4: :->knifesubcmd3' \
    '5: :->knifesubcmd4' \
    '6: :->knifesubcmd5'

  case $state in
  knifecmd)
    compadd -Q "$@" bootstrap client configure cookbook "cookbook site" "data bag" environment exec index node recipe role search ssh status tag
  ;;
  knifesubcmd)
    case $words[2] in
    client)
      compadd -Q "$@" "bulk delete" create delete edit list reregister show
    ;;
    configure)
      compadd "$@" client
    ;;
    cookbook)
      compadd -Q "$@" "bulk delete" create delete download list metadata "metadata from" show test upload
    ;;
    environment)
      compadd -Q "$@" create delete edit "from file" list show
    ;;
    node)
      compadd -Q "$@" "bulk delete" create delete edit "from file" list run_list show
    ;;
    recipe)
      compadd "$@" list
    ;;
    role)
      compadd -Q "$@" "bulk delete" create delete edit "from file" list show
    ;; 
    *)
      _arguments '2:Subsubcommands:($(_knife_options1))'
    esac
  ;;
  knifesubcmd2)
    case $words[3] in
    site)
      compadd "$@" download install list search share show unshare
    ;;
    (show|delete|edit)
      _arguments '3:Subsubcommands:($(_chef_$words[2]s_remote))'
    ;;
    (upload|test)
      _arguments '3:Subsubcommands:($(_chef_$words[2]s_local) --all)'
    ;;
    list)
      compadd -a "$@" knife_general_flags
    ;;
    bag)
      compadd -Q "$@" show edit list "from file" create delete
    ;;
    *)
      _arguments '3:Subsubcommands:($(_knife_options2))'
    esac
  ;;
  knifesubcmd3)
    case $words[3] in
    show)
      case $words[2] in
      cookbook)
        versioncomp=1
        _arguments '4:Cookbookversions:($(_cookbook_versions) latest)'
      ;;
      (node|client|role)
        compadd "$@" --attribute
      esac
    esac
    case $words[4] in
    (show|edit)
      _arguments '4:Subsubsubcommands:($(_chef_$words[2]_$words[3]s_remote))'
    ;;
    file)
      _arguments '*:file or directory:_files -g "*.(rb|json)"'
    ;;
    list)
      compadd -a "$@" knife_general_flags
    ;;
    *)
      _arguments '*:Subsubcommands:($(_knife_options3))'
    esac
  ;;
  knifesubcmd4)
    if (( versioncomp > 0 )); then
      compadd "$@" attributes definitions files libraries providers recipes resources templates
    else
      _arguments '*:Subsubcommands:($(_knife_options2))'
    fi
  ;; 
  knifesubcmd5) 
    _arguments '*:Subsubcommands:($(_knife_options3))'
  esac
}

# Helper functions to provide the argument completion for several depths of commands
_knife_options1() {
 ( for line in $( knife $words[2] --help | grep -v "^knife" ); do echo $line | grep "\-\-"; done )
}

_knife_options2() {
 ( for line in $( knife $words[2] $words[3] --help | grep -v "^knife" ); do echo $line | grep "\-\-"; done )
}

_knife_options3() {
 ( for line in $( knife $words[2] $words[3] $words[4] --help | grep -v "^knife" ); do echo $line | grep "\-\-"; done )
}

# The chef_x_remote functions use knife to get a list of objects of type x on the server
_chef_roles_remote() {
 (knife role list --format json | grep \" | awk '{print $1}' | awk -F"," '{print $1}' | awk -F"\"" '{print $2}')
}

_chef_clients_remote() {
 (knife client list --format json | grep \" | awk '{print $1}' | awk -F"," '{print $1}' | awk -F"\"" '{print $2}')
}

_chef_nodes_remote() {
 (knife node list --format json | grep \" | awk '{print $1}' | awk -F"," '{print $1}' | awk -F"\"" '{print $2}')
}

_chef_cookbooks_remote() {
 (knife cookbook list --format json | grep \" | awk '{print $1}' | awk -F"," '{print $1}' | awk -F"\"" '{print $2}')
}

_chef_sitecookbooks_remote() {
 (knife cookbook site list --format json | grep \" | awk '{print $1}' | awk -F"," '{print $1}' | awk -F"\"" '{print $2}')
}

_chef_data_bags_remote() {
 (knife data bag list --format json | grep \" | awk '{print $1}' | awk -F"," '{print $1}' | awk -F"\"" '{print $2}')
}

_chef_environments_remote() {
  (knife environment list | awk '{print $1}')
}

# The chef_x_local functions use the knife config to find the paths of relevant objects x to be uploaded to the server
_chef_cookbooks_local() {
  local knife_rb="$HOME/.chef/knife.rb"
  if [ -f ./.chef/knife.rb ]; then
    knife_rb="./.chef/knife.rb"
  fi
  (for i in $( grep cookbook_path $knife_rb | awk 'BEGIN {FS = "[" }; {print $2}' | sed 's/\,//g' | sed "s/'//g" | sed 's/\(.*\)]/\1/' ); do ls $i; done)
}

# This function extracts the available cookbook versions on the chef server
_cookbook_versions() {
  (knife cookbook show $words[4] | grep -v $words[4] | grep -v -E '\]|\[|\{|\}' | sed 's/ //g' | sed 's/"//g')
}

_knife "$@"
